/*
MetaCopier API

Explore the power of the MetaCopier API! Our RESTful API offers scalable and secure access to accounts, projects, and more. Get started quickly with authentication, explore endpoints, and access code samples in various languages.<br/><br/>All dates are in ISO 8601<br/><br/>This API is not designed for real-time communication purposes. For instance, continuously polling account information such as open positions every second is not recommended.<br/><br/>Our frontend uses this API, so you can look at the requests on our frontend for examples.

API version: 1.2.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metacopier

import (
	"bytes"
	"encoding/json"
	"fmt"
)

// checks if the FeatureExitSignalOverrideDTO type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &FeatureExitSignalOverrideDTO{}

// FeatureExitSignalOverrideDTO DTO for configuring the exit signal override feature (copier)
type FeatureExitSignalOverrideDTO struct {
	// Specifies the number of seconds to wait before closing the trade. This is useful if you want the slave account to hold the position until the Take Profit (TP) level is reached. A value of 0 indicates that the exit signal will be ignored indefinitely.
	IgnoreForSeconds *int32 `json:"ignoreForSeconds,omitempty"`
	// Indicates whether the exit signal should only be ignored if both Take Profit (TP) and Stop Loss (SL) levels are set on the trade.
	OnlyIfTpSlAreSet bool `json:"onlyIfTpSlAreSet"`
}

type _FeatureExitSignalOverrideDTO FeatureExitSignalOverrideDTO

// NewFeatureExitSignalOverrideDTO instantiates a new FeatureExitSignalOverrideDTO object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewFeatureExitSignalOverrideDTO(onlyIfTpSlAreSet bool) *FeatureExitSignalOverrideDTO {
	this := FeatureExitSignalOverrideDTO{}
	var ignoreForSeconds int32 = 5
	this.IgnoreForSeconds = &ignoreForSeconds
	this.OnlyIfTpSlAreSet = onlyIfTpSlAreSet
	return &this
}

// NewFeatureExitSignalOverrideDTOWithDefaults instantiates a new FeatureExitSignalOverrideDTO object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewFeatureExitSignalOverrideDTOWithDefaults() *FeatureExitSignalOverrideDTO {
	this := FeatureExitSignalOverrideDTO{}
	var ignoreForSeconds int32 = 5
	this.IgnoreForSeconds = &ignoreForSeconds
	var onlyIfTpSlAreSet bool = true
	this.OnlyIfTpSlAreSet = onlyIfTpSlAreSet
	return &this
}

// GetIgnoreForSeconds returns the IgnoreForSeconds field value if set, zero value otherwise.
func (o *FeatureExitSignalOverrideDTO) GetIgnoreForSeconds() int32 {
	if o == nil || IsNil(o.IgnoreForSeconds) {
		var ret int32
		return ret
	}
	return *o.IgnoreForSeconds
}

// GetIgnoreForSecondsOk returns a tuple with the IgnoreForSeconds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureExitSignalOverrideDTO) GetIgnoreForSecondsOk() (*int32, bool) {
	if o == nil || IsNil(o.IgnoreForSeconds) {
		return nil, false
	}
	return o.IgnoreForSeconds, true
}

// HasIgnoreForSeconds returns a boolean if a field has been set.
func (o *FeatureExitSignalOverrideDTO) HasIgnoreForSeconds() bool {
	if o != nil && !IsNil(o.IgnoreForSeconds) {
		return true
	}

	return false
}

// SetIgnoreForSeconds gets a reference to the given int32 and assigns it to the IgnoreForSeconds field.
func (o *FeatureExitSignalOverrideDTO) SetIgnoreForSeconds(v int32) {
	o.IgnoreForSeconds = &v
}

// GetOnlyIfTpSlAreSet returns the OnlyIfTpSlAreSet field value
func (o *FeatureExitSignalOverrideDTO) GetOnlyIfTpSlAreSet() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.OnlyIfTpSlAreSet
}

// GetOnlyIfTpSlAreSetOk returns a tuple with the OnlyIfTpSlAreSet field value
// and a boolean to check if the value has been set.
func (o *FeatureExitSignalOverrideDTO) GetOnlyIfTpSlAreSetOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.OnlyIfTpSlAreSet, true
}

// SetOnlyIfTpSlAreSet sets field value
func (o *FeatureExitSignalOverrideDTO) SetOnlyIfTpSlAreSet(v bool) {
	o.OnlyIfTpSlAreSet = v
}

func (o FeatureExitSignalOverrideDTO) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o FeatureExitSignalOverrideDTO) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.IgnoreForSeconds) {
		toSerialize["ignoreForSeconds"] = o.IgnoreForSeconds
	}
	toSerialize["onlyIfTpSlAreSet"] = o.OnlyIfTpSlAreSet
	return toSerialize, nil
}

func (o *FeatureExitSignalOverrideDTO) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"onlyIfTpSlAreSet",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varFeatureExitSignalOverrideDTO := _FeatureExitSignalOverrideDTO{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	err = decoder.Decode(&varFeatureExitSignalOverrideDTO)

	if err != nil {
		return err
	}

	*o = FeatureExitSignalOverrideDTO(varFeatureExitSignalOverrideDTO)

	return err
}

type NullableFeatureExitSignalOverrideDTO struct {
	value *FeatureExitSignalOverrideDTO
	isSet bool
}

func (v NullableFeatureExitSignalOverrideDTO) Get() *FeatureExitSignalOverrideDTO {
	return v.value
}

func (v *NullableFeatureExitSignalOverrideDTO) Set(val *FeatureExitSignalOverrideDTO) {
	v.value = val
	v.isSet = true
}

func (v NullableFeatureExitSignalOverrideDTO) IsSet() bool {
	return v.isSet
}

func (v *NullableFeatureExitSignalOverrideDTO) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFeatureExitSignalOverrideDTO(val *FeatureExitSignalOverrideDTO) *NullableFeatureExitSignalOverrideDTO {
	return &NullableFeatureExitSignalOverrideDTO{value: val, isSet: true}
}

func (v NullableFeatureExitSignalOverrideDTO) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFeatureExitSignalOverrideDTO) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
