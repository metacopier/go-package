/*
MetaCopier API

Explore the power of the MetaCopier API! Our RESTful API offers scalable and secure access to accounts, projects, and more. Get started quickly with authentication, explore endpoints, and access code samples in various languages.<br/><br/>All dates are in ISO 8601<br/><br/>This API is not designed for real-time communication purposes. For instance, continuously polling account information such as open positions every second is not recommended.<br/><br/>Our frontend uses this API, so you can look at the requests on our frontend for examples.

API version: 1.2.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metacopier

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SignalAPIAPIService SignalAPIAPI service
type SignalAPIAPIService service

type ApiCloseAllPositionsInAllFollowerAccountsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
}

func (r ApiCloseAllPositionsInAllFollowerAccountsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloseAllPositionsInAllFollowerAccountsExecute(r)
}

/*
CloseAllPositionsInAllFollowerAccounts Close all open positions in all accounts (followers)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @return ApiCloseAllPositionsInAllFollowerAccountsRequest
*/
func (a *SignalAPIAPIService) CloseAllPositionsInAllFollowerAccounts(ctx context.Context, signalProviderId string) ApiCloseAllPositionsInAllFollowerAccountsRequest {
	return ApiCloseAllPositionsInAllFollowerAccountsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
	}
}

// Execute executes the request
func (a *SignalAPIAPIService) CloseAllPositionsInAllFollowerAccountsExecute(r ApiCloseAllPositionsInAllFollowerAccountsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.CloseAllPositionsInAllFollowerAccounts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/closeAllPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloseSignalFollowerAllPositionsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
}

func (r ApiCloseSignalFollowerAllPositionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloseSignalFollowerAllPositionsExecute(r)
}

/*
CloseSignalFollowerAllPositions Close all signal follower account positions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiCloseSignalFollowerAllPositionsRequest
*/
func (a *SignalAPIAPIService) CloseSignalFollowerAllPositions(ctx context.Context, signalProviderId string, accountId string) ApiCloseSignalFollowerAllPositionsRequest {
	return ApiCloseSignalFollowerAllPositionsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *SignalAPIAPIService) CloseSignalFollowerAllPositionsExecute(r ApiCloseSignalFollowerAllPositionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.CloseSignalFollowerAllPositions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/actions/closeAllPositions"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloseSignalFollowerPositionRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
	positionId string
}

func (r ApiCloseSignalFollowerPositionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloseSignalFollowerPositionExecute(r)
}

/*
CloseSignalFollowerPosition Close an signal follower account position

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @param positionId
 @return ApiCloseSignalFollowerPositionRequest
*/
func (a *SignalAPIAPIService) CloseSignalFollowerPosition(ctx context.Context, signalProviderId string, accountId string, positionId string) ApiCloseSignalFollowerPositionRequest {
	return ApiCloseSignalFollowerPositionRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
		positionId: positionId,
	}
}

// Execute executes the request
func (a *SignalAPIAPIService) CloseSignalFollowerPositionExecute(r ApiCloseSignalFollowerPositionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.CloseSignalFollowerPosition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/positions/{positionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"positionId"+"}", url.PathEscape(parameterValueToString(r.positionId, "positionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFollowerFeatureRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
}

func (r ApiGetFollowerFeatureRequest) Execute() (*FeatureDTO, *http.Response, error) {
	return r.ApiService.GetFollowerFeatureExecute(r)
}

/*
GetFollowerFeature Get follower feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetFollowerFeatureRequest
*/
func (a *SignalAPIAPIService) GetFollowerFeature(ctx context.Context, signalProviderId string, accountId string) ApiGetFollowerFeatureRequest {
	return ApiGetFollowerFeatureRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return FeatureDTO
func (a *SignalAPIAPIService) GetFollowerFeatureExecute(r ApiGetFollowerFeatureRequest) (*FeatureDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetFollowerFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/followerFeature"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountAuditLogsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
	limit *int32
	offset *int32
	startDate *string
	endDate *string
}

// Maximum number of logs to return
func (r ApiGetSignalFollowerAccountAuditLogsRequest) Limit(limit int32) ApiGetSignalFollowerAccountAuditLogsRequest {
	r.limit = &limit
	return r
}

// Number of logs to skip for pagination
func (r ApiGetSignalFollowerAccountAuditLogsRequest) Offset(offset int32) ApiGetSignalFollowerAccountAuditLogsRequest {
	r.offset = &offset
	return r
}

// Start date filter (ISO-8601 format)
func (r ApiGetSignalFollowerAccountAuditLogsRequest) StartDate(startDate string) ApiGetSignalFollowerAccountAuditLogsRequest {
	r.startDate = &startDate
	return r
}

// End date filter (ISO-8601 format)
func (r ApiGetSignalFollowerAccountAuditLogsRequest) EndDate(endDate string) ApiGetSignalFollowerAccountAuditLogsRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGetSignalFollowerAccountAuditLogsRequest) Execute() ([]AuditLogDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountAuditLogsExecute(r)
}

/*
GetSignalFollowerAccountAuditLogs Get signal follower account audit logs

Retrieves audit logs for all API modifications made to a specific signal follower account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalFollowerAccountAuditLogsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccountAuditLogs(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalFollowerAccountAuditLogsRequest {
	return ApiGetSignalFollowerAccountAuditLogsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []AuditLogDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountAuditLogsExecute(r ApiGetSignalFollowerAccountAuditLogsRequest) ([]AuditLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AuditLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccountAuditLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/auditLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountHistoryPositionsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
	start *string
	stop *string
}

// ISO 8601
func (r ApiGetSignalFollowerAccountHistoryPositionsRequest) Start(start string) ApiGetSignalFollowerAccountHistoryPositionsRequest {
	r.start = &start
	return r
}

// ISO 8601
func (r ApiGetSignalFollowerAccountHistoryPositionsRequest) Stop(stop string) ApiGetSignalFollowerAccountHistoryPositionsRequest {
	r.stop = &stop
	return r
}

func (r ApiGetSignalFollowerAccountHistoryPositionsRequest) Execute() ([]PositionDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountHistoryPositionsExecute(r)
}

/*
GetSignalFollowerAccountHistoryPositions Get signal follower account history positions

The history is not updated in real-time. There may be a delay of up to 3 minutes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalFollowerAccountHistoryPositionsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccountHistoryPositions(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalFollowerAccountHistoryPositionsRequest {
	return ApiGetSignalFollowerAccountHistoryPositionsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PositionDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountHistoryPositionsExecute(r ApiGetSignalFollowerAccountHistoryPositionsRequest) ([]PositionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PositionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccountHistoryPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/history/positions"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.stop == nil {
		return localVarReturnValue, nil, reportError("stop is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "stop", r.stop, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountLogsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
	limit *int32
	offset *int32
	start *string
	stop *string
	logTypeId *int32
}

// Get the last logs: e.g. 100 means the last 100 logs
func (r ApiGetSignalFollowerAccountLogsRequest) Limit(limit int32) ApiGetSignalFollowerAccountLogsRequest {
	r.limit = &limit
	return r
}

// You can set an offset. Offset 100 means 101-200
func (r ApiGetSignalFollowerAccountLogsRequest) Offset(offset int32) ApiGetSignalFollowerAccountLogsRequest {
	r.offset = &offset
	return r
}

// ISO 8601
func (r ApiGetSignalFollowerAccountLogsRequest) Start(start string) ApiGetSignalFollowerAccountLogsRequest {
	r.start = &start
	return r
}

// ISO 8601
func (r ApiGetSignalFollowerAccountLogsRequest) Stop(stop string) ApiGetSignalFollowerAccountLogsRequest {
	r.stop = &stop
	return r
}

// Filter logs by log level type ID. If you choose 3 &#x3D; Info, then all logs with a lower level are returned. The levels are: 1 &#x3D; Error, 2 &#x3D; Warning, 3 &#x3D; Info.
func (r ApiGetSignalFollowerAccountLogsRequest) LogTypeId(logTypeId int32) ApiGetSignalFollowerAccountLogsRequest {
	r.logTypeId = &logTypeId
	return r
}

func (r ApiGetSignalFollowerAccountLogsRequest) Execute() ([]LogDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountLogsExecute(r)
}

/*
GetSignalFollowerAccountLogs Get signal follower account logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalFollowerAccountLogsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccountLogs(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalFollowerAccountLogsRequest {
	return ApiGetSignalFollowerAccountLogsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []LogDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountLogsExecute(r ApiGetSignalFollowerAccountLogsRequest) ([]LogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccountLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.stop != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stop", r.stop, "form", "")
	}
	if r.logTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logTypeId", r.logTypeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountPerformanceMetricsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
}

func (r ApiGetSignalFollowerAccountPerformanceMetricsRequest) Execute() (*PerformanceMetricsDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountPerformanceMetricsExecute(r)
}

/*
GetSignalFollowerAccountPerformanceMetrics Get signal follower account performance metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalFollowerAccountPerformanceMetricsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccountPerformanceMetrics(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalFollowerAccountPerformanceMetricsRequest {
	return ApiGetSignalFollowerAccountPerformanceMetricsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PerformanceMetricsDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountPerformanceMetricsExecute(r ApiGetSignalFollowerAccountPerformanceMetricsRequest) (*PerformanceMetricsDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PerformanceMetricsDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccountPerformanceMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/performanceMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountPositionsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
}

func (r ApiGetSignalFollowerAccountPositionsRequest) Execute() ([]PositionDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountPositionsExecute(r)
}

/*
GetSignalFollowerAccountPositions Get signal follower account positions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalFollowerAccountPositionsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccountPositions(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalFollowerAccountPositionsRequest {
	return ApiGetSignalFollowerAccountPositionsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PositionDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountPositionsExecute(r ApiGetSignalFollowerAccountPositionsRequest) ([]PositionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PositionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccountPositions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/positions"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalFollowerAccountsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
}

func (r ApiGetSignalFollowerAccountsRequest) Execute() ([]AccountDTO, *http.Response, error) {
	return r.ApiService.GetSignalFollowerAccountsExecute(r)
}

/*
GetSignalFollowerAccounts Get all signal follower accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @return ApiGetSignalFollowerAccountsRequest
*/
func (a *SignalAPIAPIService) GetSignalFollowerAccounts(ctx context.Context, signalProviderId string) ApiGetSignalFollowerAccountsRequest {
	return ApiGetSignalFollowerAccountsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
	}
}

// Execute executes the request
//  @return []AccountDTO
func (a *SignalAPIAPIService) GetSignalFollowerAccountsExecute(r ApiGetSignalFollowerAccountsRequest) ([]AccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalFollowerAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignalSymbolsRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
}

func (r ApiGetSignalSymbolsRequest) Execute() ([]SymbolDTO, *http.Response, error) {
	return r.ApiService.GetSignalSymbolsExecute(r)
}

/*
GetSignalSymbols Get signal follower account symbols

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiGetSignalSymbolsRequest
*/
func (a *SignalAPIAPIService) GetSignalSymbols(ctx context.Context, signalProviderId string, accountId string) ApiGetSignalSymbolsRequest {
	return ApiGetSignalSymbolsRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []SymbolDTO
func (a *SignalAPIAPIService) GetSignalSymbolsExecute(r ApiGetSignalSymbolsRequest) ([]SymbolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SymbolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.GetSignalSymbols")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/symbols"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFollowerFeatureRequest struct {
	ctx context.Context
	ApiService *SignalAPIAPIService
	signalProviderId string
	accountId string
	featureDTO *FeatureDTO
}

func (r ApiUpdateFollowerFeatureRequest) FeatureDTO(featureDTO FeatureDTO) ApiUpdateFollowerFeatureRequest {
	r.featureDTO = &featureDTO
	return r
}

func (r ApiUpdateFollowerFeatureRequest) Execute() (*FeatureDTO, *http.Response, error) {
	return r.ApiService.UpdateFollowerFeatureExecute(r)
}

/*
UpdateFollowerFeature Update follower feature

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param signalProviderId
 @param accountId
 @return ApiUpdateFollowerFeatureRequest
*/
func (a *SignalAPIAPIService) UpdateFollowerFeature(ctx context.Context, signalProviderId string, accountId string) ApiUpdateFollowerFeatureRequest {
	return ApiUpdateFollowerFeatureRequest{
		ApiService: a,
		ctx: ctx,
		signalProviderId: signalProviderId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return FeatureDTO
func (a *SignalAPIAPIService) UpdateFollowerFeatureExecute(r ApiUpdateFollowerFeatureRequest) (*FeatureDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignalAPIAPIService.UpdateFollowerFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/api/v1/signals/{signalProviderId}/accounts/{accountId}/followerFeature"
	localVarPath = strings.Replace(localVarPath, "{"+"signalProviderId"+"}", url.PathEscape(parameterValueToString(r.signalProviderId, "signalProviderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.featureDTO == nil {
		return localVarReturnValue, nil, reportError("featureDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.featureDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
