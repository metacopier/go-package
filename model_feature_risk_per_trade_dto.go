/*
MetaCopier API

Explore the power of the MetaCopier API! Our RESTful API offers scalable and secure access to accounts, projects, and more. Get started quickly with authentication, explore endpoints, and access code samples in various languages.<br/><br/>All dates are in ISO 8601<br/><br/>This API is not designed for real-time communication purposes. For instance, continuously polling account information such as open positions every second is not recommended.<br/><br/>Our frontend uses this API, so you can look at the requests on our frontend for examples.

API version: 1.2.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metacopier

import (
	"encoding/json"
)

// checks if the FeatureRiskPerTradeDTO type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &FeatureRiskPerTradeDTO{}

// FeatureRiskPerTradeDTO DTO for risk per trade feature (copier/account)
type FeatureRiskPerTradeDTO struct {
	// Defines the risk per trade as a fixed absolute value (e.g., 50 USD). If set to 0, this mode is disabled.
	AbsoluteRisk *float32 `json:"absoluteRisk,omitempty"`
	// If enabled, aggregates risk calculation across all open positions for the same symbol. When true and multiple positions exist for a symbol (e.g., XAUUSD), the total risk will be calculated by summing all open positions for that symbol before checking against the risk limits. When false, each position is evaluated independently.
	AggregateRiskPerSymbol *bool `json:"aggregateRiskPerSymbol,omitempty"`
	// If enabled, adjusts the lot size automatically based on the distance to the stop loss (SL). Ensures that the actual monetary risk per trade aligns with the configured percentage or absolute risk. This calculation only applies when a stop loss is defined on the master trade. Only valid for copier.
	CorrectLotSizeBasedOnTheStopLoss *bool `json:"correctLotSizeBasedOnTheStopLoss,omitempty"`
	// Defines the risk per trade as a percentage of the account balance. If set to 0, this mode is disabled.
	RelativeRisk *float32 `json:"relativeRisk,omitempty"`
	// Defines risk per trader per symbol. Symbol configuration has priority over the general configuration.
	SymbolsConfiguration *map[string]FeatureRiskPerTradeDTO `json:"symbolsConfiguration,omitempty"`
	// Monetary value of one point (smallest price increment) per 1.0 lot, already expressed in the account currency.
	TickValue *float32 `json:"tickValue,omitempty"`
	// Enable automatic detection of the point-value in account currency from live trades. When true, the system overrides `tickValue` with the detected value at runtime.
	TickValueAutomaticAdjustement *bool `json:"tickValueAutomaticAdjustement,omitempty"`
}

// NewFeatureRiskPerTradeDTO instantiates a new FeatureRiskPerTradeDTO object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewFeatureRiskPerTradeDTO() *FeatureRiskPerTradeDTO {
	this := FeatureRiskPerTradeDTO{}
	var absoluteRisk float32 = 0
	this.AbsoluteRisk = &absoluteRisk
	var aggregateRiskPerSymbol bool = false
	this.AggregateRiskPerSymbol = &aggregateRiskPerSymbol
	var correctLotSizeBasedOnTheStopLoss bool = false
	this.CorrectLotSizeBasedOnTheStopLoss = &correctLotSizeBasedOnTheStopLoss
	var relativeRisk float32 = 0
	this.RelativeRisk = &relativeRisk
	var tickValue float32 = 0
	this.TickValue = &tickValue
	var tickValueAutomaticAdjustement bool = true
	this.TickValueAutomaticAdjustement = &tickValueAutomaticAdjustement
	return &this
}

// NewFeatureRiskPerTradeDTOWithDefaults instantiates a new FeatureRiskPerTradeDTO object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewFeatureRiskPerTradeDTOWithDefaults() *FeatureRiskPerTradeDTO {
	this := FeatureRiskPerTradeDTO{}
	var absoluteRisk float32 = 0
	this.AbsoluteRisk = &absoluteRisk
	var aggregateRiskPerSymbol bool = false
	this.AggregateRiskPerSymbol = &aggregateRiskPerSymbol
	var correctLotSizeBasedOnTheStopLoss bool = false
	this.CorrectLotSizeBasedOnTheStopLoss = &correctLotSizeBasedOnTheStopLoss
	var relativeRisk float32 = 0
	this.RelativeRisk = &relativeRisk
	var tickValue float32 = 0
	this.TickValue = &tickValue
	var tickValueAutomaticAdjustement bool = true
	this.TickValueAutomaticAdjustement = &tickValueAutomaticAdjustement
	return &this
}

// GetAbsoluteRisk returns the AbsoluteRisk field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetAbsoluteRisk() float32 {
	if o == nil || IsNil(o.AbsoluteRisk) {
		var ret float32
		return ret
	}
	return *o.AbsoluteRisk
}

// GetAbsoluteRiskOk returns a tuple with the AbsoluteRisk field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetAbsoluteRiskOk() (*float32, bool) {
	if o == nil || IsNil(o.AbsoluteRisk) {
		return nil, false
	}
	return o.AbsoluteRisk, true
}

// HasAbsoluteRisk returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasAbsoluteRisk() bool {
	if o != nil && !IsNil(o.AbsoluteRisk) {
		return true
	}

	return false
}

// SetAbsoluteRisk gets a reference to the given float32 and assigns it to the AbsoluteRisk field.
func (o *FeatureRiskPerTradeDTO) SetAbsoluteRisk(v float32) {
	o.AbsoluteRisk = &v
}

// GetAggregateRiskPerSymbol returns the AggregateRiskPerSymbol field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetAggregateRiskPerSymbol() bool {
	if o == nil || IsNil(o.AggregateRiskPerSymbol) {
		var ret bool
		return ret
	}
	return *o.AggregateRiskPerSymbol
}

// GetAggregateRiskPerSymbolOk returns a tuple with the AggregateRiskPerSymbol field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetAggregateRiskPerSymbolOk() (*bool, bool) {
	if o == nil || IsNil(o.AggregateRiskPerSymbol) {
		return nil, false
	}
	return o.AggregateRiskPerSymbol, true
}

// HasAggregateRiskPerSymbol returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasAggregateRiskPerSymbol() bool {
	if o != nil && !IsNil(o.AggregateRiskPerSymbol) {
		return true
	}

	return false
}

// SetAggregateRiskPerSymbol gets a reference to the given bool and assigns it to the AggregateRiskPerSymbol field.
func (o *FeatureRiskPerTradeDTO) SetAggregateRiskPerSymbol(v bool) {
	o.AggregateRiskPerSymbol = &v
}

// GetCorrectLotSizeBasedOnTheStopLoss returns the CorrectLotSizeBasedOnTheStopLoss field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetCorrectLotSizeBasedOnTheStopLoss() bool {
	if o == nil || IsNil(o.CorrectLotSizeBasedOnTheStopLoss) {
		var ret bool
		return ret
	}
	return *o.CorrectLotSizeBasedOnTheStopLoss
}

// GetCorrectLotSizeBasedOnTheStopLossOk returns a tuple with the CorrectLotSizeBasedOnTheStopLoss field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetCorrectLotSizeBasedOnTheStopLossOk() (*bool, bool) {
	if o == nil || IsNil(o.CorrectLotSizeBasedOnTheStopLoss) {
		return nil, false
	}
	return o.CorrectLotSizeBasedOnTheStopLoss, true
}

// HasCorrectLotSizeBasedOnTheStopLoss returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasCorrectLotSizeBasedOnTheStopLoss() bool {
	if o != nil && !IsNil(o.CorrectLotSizeBasedOnTheStopLoss) {
		return true
	}

	return false
}

// SetCorrectLotSizeBasedOnTheStopLoss gets a reference to the given bool and assigns it to the CorrectLotSizeBasedOnTheStopLoss field.
func (o *FeatureRiskPerTradeDTO) SetCorrectLotSizeBasedOnTheStopLoss(v bool) {
	o.CorrectLotSizeBasedOnTheStopLoss = &v
}

// GetRelativeRisk returns the RelativeRisk field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetRelativeRisk() float32 {
	if o == nil || IsNil(o.RelativeRisk) {
		var ret float32
		return ret
	}
	return *o.RelativeRisk
}

// GetRelativeRiskOk returns a tuple with the RelativeRisk field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetRelativeRiskOk() (*float32, bool) {
	if o == nil || IsNil(o.RelativeRisk) {
		return nil, false
	}
	return o.RelativeRisk, true
}

// HasRelativeRisk returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasRelativeRisk() bool {
	if o != nil && !IsNil(o.RelativeRisk) {
		return true
	}

	return false
}

// SetRelativeRisk gets a reference to the given float32 and assigns it to the RelativeRisk field.
func (o *FeatureRiskPerTradeDTO) SetRelativeRisk(v float32) {
	o.RelativeRisk = &v
}

// GetSymbolsConfiguration returns the SymbolsConfiguration field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetSymbolsConfiguration() map[string]FeatureRiskPerTradeDTO {
	if o == nil || IsNil(o.SymbolsConfiguration) {
		var ret map[string]FeatureRiskPerTradeDTO
		return ret
	}
	return *o.SymbolsConfiguration
}

// GetSymbolsConfigurationOk returns a tuple with the SymbolsConfiguration field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetSymbolsConfigurationOk() (*map[string]FeatureRiskPerTradeDTO, bool) {
	if o == nil || IsNil(o.SymbolsConfiguration) {
		return nil, false
	}
	return o.SymbolsConfiguration, true
}

// HasSymbolsConfiguration returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasSymbolsConfiguration() bool {
	if o != nil && !IsNil(o.SymbolsConfiguration) {
		return true
	}

	return false
}

// SetSymbolsConfiguration gets a reference to the given map[string]FeatureRiskPerTradeDTO and assigns it to the SymbolsConfiguration field.
func (o *FeatureRiskPerTradeDTO) SetSymbolsConfiguration(v map[string]FeatureRiskPerTradeDTO) {
	o.SymbolsConfiguration = &v
}

// GetTickValue returns the TickValue field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetTickValue() float32 {
	if o == nil || IsNil(o.TickValue) {
		var ret float32
		return ret
	}
	return *o.TickValue
}

// GetTickValueOk returns a tuple with the TickValue field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetTickValueOk() (*float32, bool) {
	if o == nil || IsNil(o.TickValue) {
		return nil, false
	}
	return o.TickValue, true
}

// HasTickValue returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasTickValue() bool {
	if o != nil && !IsNil(o.TickValue) {
		return true
	}

	return false
}

// SetTickValue gets a reference to the given float32 and assigns it to the TickValue field.
func (o *FeatureRiskPerTradeDTO) SetTickValue(v float32) {
	o.TickValue = &v
}

// GetTickValueAutomaticAdjustement returns the TickValueAutomaticAdjustement field value if set, zero value otherwise.
func (o *FeatureRiskPerTradeDTO) GetTickValueAutomaticAdjustement() bool {
	if o == nil || IsNil(o.TickValueAutomaticAdjustement) {
		var ret bool
		return ret
	}
	return *o.TickValueAutomaticAdjustement
}

// GetTickValueAutomaticAdjustementOk returns a tuple with the TickValueAutomaticAdjustement field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *FeatureRiskPerTradeDTO) GetTickValueAutomaticAdjustementOk() (*bool, bool) {
	if o == nil || IsNil(o.TickValueAutomaticAdjustement) {
		return nil, false
	}
	return o.TickValueAutomaticAdjustement, true
}

// HasTickValueAutomaticAdjustement returns a boolean if a field has been set.
func (o *FeatureRiskPerTradeDTO) HasTickValueAutomaticAdjustement() bool {
	if o != nil && !IsNil(o.TickValueAutomaticAdjustement) {
		return true
	}

	return false
}

// SetTickValueAutomaticAdjustement gets a reference to the given bool and assigns it to the TickValueAutomaticAdjustement field.
func (o *FeatureRiskPerTradeDTO) SetTickValueAutomaticAdjustement(v bool) {
	o.TickValueAutomaticAdjustement = &v
}

func (o FeatureRiskPerTradeDTO) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o FeatureRiskPerTradeDTO) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.AbsoluteRisk) {
		toSerialize["absoluteRisk"] = o.AbsoluteRisk
	}
	if !IsNil(o.AggregateRiskPerSymbol) {
		toSerialize["aggregateRiskPerSymbol"] = o.AggregateRiskPerSymbol
	}
	if !IsNil(o.CorrectLotSizeBasedOnTheStopLoss) {
		toSerialize["correctLotSizeBasedOnTheStopLoss"] = o.CorrectLotSizeBasedOnTheStopLoss
	}
	if !IsNil(o.RelativeRisk) {
		toSerialize["relativeRisk"] = o.RelativeRisk
	}
	if !IsNil(o.SymbolsConfiguration) {
		toSerialize["symbolsConfiguration"] = o.SymbolsConfiguration
	}
	if !IsNil(o.TickValue) {
		toSerialize["tickValue"] = o.TickValue
	}
	if !IsNil(o.TickValueAutomaticAdjustement) {
		toSerialize["tickValueAutomaticAdjustement"] = o.TickValueAutomaticAdjustement
	}
	return toSerialize, nil
}

type NullableFeatureRiskPerTradeDTO struct {
	value *FeatureRiskPerTradeDTO
	isSet bool
}

func (v NullableFeatureRiskPerTradeDTO) Get() *FeatureRiskPerTradeDTO {
	return v.value
}

func (v *NullableFeatureRiskPerTradeDTO) Set(val *FeatureRiskPerTradeDTO) {
	v.value = val
	v.isSet = true
}

func (v NullableFeatureRiskPerTradeDTO) IsSet() bool {
	return v.isSet
}

func (v *NullableFeatureRiskPerTradeDTO) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFeatureRiskPerTradeDTO(val *FeatureRiskPerTradeDTO) *NullableFeatureRiskPerTradeDTO {
	return &NullableFeatureRiskPerTradeDTO{value: val, isSet: true}
}

func (v NullableFeatureRiskPerTradeDTO) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFeatureRiskPerTradeDTO) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
